# SMART-ACCOUNT

a [smart account][4] solution for [CosmWasm][1]-enabled chains.

In our context, `smart account` is a contract account associated with a public key, so it can be considered a programmable EOA. The difference is that unlike an EOA account where **Address** and **PubKey** must be the same, the **PubKey** of a `smart account` can be any key that the account owner set for it. 

Our new account will have **SmartAccount** type instead of [BaseAccount][5] or other existing types.

</br>

## Activation Account 
Like EOA, users can create a local `smart account` and decide when to actually use it. This achived by using cosmwasm [Instantiate2][3] method which will generate an account with predictable address. 
- `Instantiate2` method params 
    - **sender**: actor that signerd the messages. 
    - **admin**: optional address that can execute migrations. 
    - **code_id**: reference to the stored WASM code. 
    - **label**: optional metadata to be stored with a contract instance. 
    - **msg**: json encoded message to be passed to the contract on instantiation. 
    - **funds**: coins that are transferred to the contract on instantiation. 
    - **salt**: an arbitrary value provided by the sender. Size can be 1 to 64. 
    - **fix_msg**: include the msg value into the hash for the predictable address. Default is false.  

</br>

### Query `generate-account` 
Allows users to generate smart account addresses locally based on optional configuration
```Go
type QueryGenerateAccount struct{
    // reference to the stored WASM code, must be in whitelist
    code_id    uint64

    // an arbitrary value provided by the sender. Size can be 1 to 64.
    salt       []byte

    // json encoded message to be passed to the contract on instantiation
    init_msg   []byte

    // public key of this account, must be cosmos supported schemas
    public_key Any
}
``` 

Internally a address is built by `Instantiate2` containing:
```
(len(checksum) | checksum | len(sender_address) | sender_address | len(salt) | salt| len(initMsg) | initMsg)
```
When create a new EOA, users can generate their private key locally and claim their account without sending any transactions. In our smart account case, using `public_key` as `sender_address`, a smart account can be claimed to be owned by the user who has configured the parameters to generate the account address.

</br>

### Message `activate-account`
Allows users to activate their smart account. This message will take an account with type **BaseAccount** and convert it to **SmartAccount** type with preconfigured public key. Account address must be generated by `QueryGenerateAccount` query 
```Go
type MessageActivateAccount struct {
    // AccountAddress is the actor who signs the message
    account_address string

    // reference to the stored WASM code, must be in whitelist
    code_id         uint64

    // an arbitrary value provided by the sender. Size can be 1 to 64.
    salt            []byte

    // json encoded message to be passed to the contract on instantiation
    init_msg        []byte

    // public key of this account, must be cosmos supported schemas
    public_key      Any
}
```

This message is signed with the user's private key and the signer is a pre-generated account. The module will calculate the expected address based on the input parameters then compare with the signer's address, so all configuration needs to match that used for the `QueryGenerateAccount` query.

</br>

To illustrate this in a graph:

```plain
             tx
              ↓
  ┌───── Antehandler ─────┐
  │   ┌───────────────┐   │
  │   │  decorator 0  │   │
  │   └───────────────┘   │
  │   ┌───────────────┐   │ Set temporary PubKey      ┌───────────────┐
  │   │  SA SetPubKey │---│-------------------------->|  auth module  |
  │   └───────────────┘   │                           └───────────────┘
  |      ...........      |
  │   ┌───────────────┐   │
  │   │SigVerification│   │
  │   └───────────────┘   │
  |      ...........      |
  │   ┌───────────────┐   │ Remove temporary Pubkey   ┌───────────────┐
  │   │  SA decorator │---│-------------------------->|  auth module  |
  │   └───────────────┘   │                           └───────────────┘
  │   ┌───────────────┐   │
  │   │  decorator 2  │   │
  │   └───────────────┘   │
  └───────────────────────┘
              ↓
      ┌────────────────┐
      │  msg activate  │ 
      └────────────────┘
              ↓
  ┌───────  module ───────┐
  │   ┌───────────────┐   │   instantiate contract   ┌───────────────┐
  │   │   SA module   │---│------------------------->|  wasmd module |
  │   └───────────────┘   │                          └───────────────┘
  └───────────────────────┘
              ↓
            done
```
- **AnteHandler**
    - Since the account doesn't have **PubKey** yet, for signature verification, `SA SetPubKey` will set a temporary **PubKey** for this account using the `public_key` parameter in the message.
    - After successful signature verification, `SA decorator` will remove temporary **PubKey** so that `SA module` can initiate contract with this account later (action remove only needed in DeliveryTx).
- **SA module**
    - if the message meets all the checks, the module initiates a contract based on its parameters. The new contract will be linked to the pre-generated account (contract address will be same as account address). The module will then convert account to type `SmartAccount` and set **PubKey** for it. Finnaly, save account to `auth` module.

</br>

**Required**
- valid parameters.
- The account must have received the funds, so it can exist on-chain as **BaseAccount** type with an account number, sequence and empty public key before activated.
- The account address was not used to initiate any smart contract before.
- In some cases, we also allow reactivation of activated accounts that are not linked to any smart contracts.
- **code_id** must be in whitelist.
- `actiavte message` is the only message in tx.
 
</br>

## Recover Account
We provide a smart account recovery way in case the user forgets the account's private key or wants to change the new one. Recovery is simply changing the **PubKey** of an account of type **SmartAccount** with the new setting. This is not a required function so users can choose whether their account is recoverable or not.

</br>

### Message `recover`
The caller specifies the address to recover, the public key and provides credentials to prove they have the authority to perform the recovery.
```Go
type MsgRecover struct{
  // Sender is the actor who signs the message
  creator     string

  // smart-account address that want to recover
  address     string

  // New PubKey using for signature verification of this account, 
  // must be cosmos supported schemas
  public_key  Any

  // Credentials
  credentials string
}
```
The module makes a call to the `recover` method of contract that linked to smart account. If the message parameters meet the verification logic implemented in the contract, the smart account will be updated with the new **PubKey**.
- `recover` call
    ```Go
    type RecoverTx struct {
        Caller      string 
        PubKey      []byte
        Credentials []byte
    }
    ```

</br>

To illustrate this in a graph:

```plain
             tx
              ↓
  ┌───── Antehandler ─────┐
  │   ┌───────────────┐   │
  │   │  decorator 0  │   │
  │   └───────────────┘   │
  │   ┌───────────────┐   │
  │   │  decorator 1  │   │
  │   └───────────────┘   │ 
  │   ┌───────────────┐   │
  │   │  decorator 2  │   │
  │   └───────────────┘   │
  └───────────────────────┘
              ↓
      ┌────────────────┐
      │  msg recover   │ 
      └────────────────┘
              ↓
  ┌───────  module ───────┐
  │   ┌───────────────┐   │   `recover` sudo      ┌───────────────┐
  │   │   SA module   │---│---------------------->|  wasmd module |
  │   └───────────────┘   │                       └───────────────┘
  └───────────────────────┘
              ↓
            done
```
- **SA Module**
    - The `SA module` checks if the requested account is of type `SmartAccount`, if not, rejects it.
    - if `recover` call success, module will update new **PubKey** for account then save account to `auth` module.

</br>

**Required**
- valid parameters.
- Account with *address* must exists on-chain and has type **SmartAccount**.
- Account enables recovery function by implementing `recover` method in **sudo** entry point of linked smart contract.

</br> 

## Smart account Tx 
Users can use smart accounts to sign and broadcast tx just like EOA.

Firstly, for pre-validation tx, the AnteHandler will trigger the smartcontract's `pre_execute` method, which is linked to the account. The user won't be charged for gas if it fails because the tx won't be allowed to join the mempool. Finnaly, following the execution of tx, the `after_execute` method will be used to ascertain the success or failure of tx.

The user won't be charged for the `pre_execute` or `after execute` calls because their consuming gas won't count to total gas used. However, they are limited by the `MaxGasExecute` param.

</br>

To illustrate this in a graph:

```plain
             tx
              ↓
  ┌───── Antehandler ─────┐
  │   ┌───────────────┐   │
  │   │ SA SetPubKey  │   │
  │   └───────────────┘   │
  │   ┌───────────────┐   │   `pre_execute` execute   ┌───────────────┐
  │   │ SA decorator  │---│-------------------------->|  wasmd module |
  │   └───────────────┘   │                           └───────────────┘
  └───────────────────────┘
              ↓
      ┌────────────────┐
      │      msg 0     │
      └────────────────┘
          ...........
      ┌────────────────┐
      │      msg 1     │
      └────────────────┘
              ↓
  ┌───────  module ───────┐
  │   ┌───────────────┐   │
  │   │    module 1   │   │
  │   └───────────────┘   │
  │   ┌───────────────┐   │
  │   │    module 2   │   │
  │   └───────────────┘   │
  └───────────────────────┘
              ↓
  ┌───── Posthandler ─────┐
  │   ┌───────────────┐   │   `after_execute` execute ┌───────────────┐
  │   │ SA decorator  │---│-------------------------->|  wasmd module |
  │   └───────────────┘   │                           └───────────────┘
  └───────────────────────┘
            done
```
- **Antehandler**
    - tx will be identified as signed by smart account. If true, it will be redirected to `SA SetPubKey` and `SA decorator`
    - `smart account` tx will go through the `SA SetPubKey` decorator instead of the `auth SetPubKey` decorator. This avoiding the check for similarity of **Account Address** and **PubKey**. 
    
</br>

**Required**
- Signer is account with type **SmartAccount**

</br> 

## Params
Parameters are updatable by the module's authority, typically set to the gov module account.
- `max_gas_execute`: limit how much gas can be consumed by the `pre_execute` and `after_execute` method
- `whitelist_code_id`: determine which **code_id** can be instantiated as a `smart account`
- `disable_msgs_list`: list of msgs that `smart account` not allowed to execute

</br> 

## WASM
To be considered as `smart account`, smart contract linked with account must implement sudo methods, `after_execute` and `pre_execute`:
```Rust
// sudo method
struct AfterExecute {
    //list of messages in transaction 
    pub msgs: Vec<Any>,
    // fee information of transaction
    pub call_info: CallInfo,
    // Is tx executed throught authz msg
    pub is_authz: bool
}

// sudo method
struct PreExecute { 
    //list of messages in transaction 
    pub msgs: Vec<Any>,
    // fee information of transaction
    pub call_info: CallInfo,
    // Is tx executed throught authz msg
    pub is_authz: bool
}
```
- **Any**: is json encoded message
    ```Rust
    struct MsgData {
        pub type_url: String, // url type of message
        pub value:    Binary, // value of message
        // etc.
        //  MsgData {
        //      type_url: "/cosmos.bank.v1beta1.MsgSend",
        //      value: [...]
        //  }
    }
    ```
- **CallInfo**: is tx's fee information
    ```Rust
    pub struct CallInfo {
        pub fee: Vec<Coin>,
        pub gas: u64,
        pub fee_payer: String,
        pub fee_granter: String,
    }
    ```
- `pre_execute` and `after_execute` method must not consume exceed `max_gas_execute` gas 

Optional sudo method recover that activate the smart account recovery function
```Rust
// sudo method
struct Recover {
    pub caller: String,
    pub pub_key: Binary,
    pub credentials: Binary,
}
```

[smart account samples][2]


# x/smartaccount
- `types/auranw` is deprecated, used for **v0.7.0** migration only, and will be removed later. 

[1]: https://cosmwasm.com/
[2]: https://github.com/aura-nw/smart-account-sample/
[3]: https://github.com/CosmWasm/wasmd/blob/main/x/wasm/keeper/msg_server.go#L79-L110
[4]: https://aura-network.notion.site/Smart-Account-e69e51d6449b46dcb7c157a325dfb44f
[5]: https://github.com/cosmos/cosmos-sdk/blob/main/x/auth/types/account.go